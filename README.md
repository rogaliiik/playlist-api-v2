# Тестовое задание для поступления в GoCloudCamp
_________________

## Ответы на вопросы
1. Опишите самую интересную задачу в программировании, которую вам приходилось решать?

Интересной задачей для меня было написание сервиса для взаимодействия с NFT в блокчейне Ethereum
на фреймворке web3. Так как в целом блокчейн - это новая сфера информационных технологий и было
интересно разобраться с тем, как она устроена.

2. Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?

Увы, мне не приходилось ронять продакшн, поэтому я не могу этим похвастаться.
Но, однажды я делал восстановление для GreenPlum и указал слишком маленький дефолтный размер диска для
реплики. Однако, я заметил это уже и позже откатил без инцидентов. Благо GreenPlum имеет не настолько широкое распространение.

3. Каковы ваши ожидания от участия в буткемпе?

Хотелось бы много писать производительного кода на gRPC, разрабатывать микросервисы, а также разрабатывать облачную инфраструктуру,
так как я имею небольшой опыт в этом направлении. В дальнейшем хотелось бы присоединиться к команде.

## Задание
Задание выполняется на языке Go.

### Часть 1: https://github.com/rogaliiik/playlist

### Часть 2: Построение API для музыкального плейлиста
Реализовать сервис, который позволит управлять музыкальным плейлистом. Доступ к сервису должен осуществляться с помощью API, который имеет возможность выполнять CRUD операции с песнями в плейлисте, а также воспроизводить, приостанавливать, переходить к следующему и предыдущему трекам. Конфигурация может храниться в любом источнике данных, будь то файл на диске, либо база данных. Для удобства интеграции с сервисом может быть реализована клиентская библиотека.

### Реализация
- Приложение представляет из себя CRUD API, которое возвращает результат запроса в формате `json`.
- В качестве HTTP роутера используется библиотека `/gorilla/mux`.
- В качестве хранилица для данных приложения используется СУБД PostgreSQL. 
Модель `Song` представляет собой узел двусвязного списка и содержит номер следующего и предыдущего элемента.
```go
type Song struct {
    gorm.Model
    Title    string `json:"title"`
    Duration uint   `json:"duration"`
    Next     uint   `json:"next" gorm:"default:0"`
    Prev     uint   `json:"prev" gorm:"default:0"`
}
```
В качестве ORM для взаимодействия с базой данных используется библиотека `GORM`.

- Для сохранения состояния плейлиста в базе данных содержится модель `Playlist`.
В ней хранится индекс текущей песни, текущее состояние и таймкод. При перезапуске сервера проигрывание
продолжается из того же состояния и той же песни.

- Реализованы unit-тесты для основных эндпоинтов. Используется библиотека `testify`.
- Можно использовать `Makefile` для сборки и тестирования утилиты.
- Написаны `Dockerfile` и `docker-compose` для контейнеризации приложения.
- Приложение было протестировано вручную с помощью `Postman`.

### Запуск программы

Установите зависимости с помощью:

```go
go mod download
```

Компиляция программы возможна с помощью утилиты cmake (если она предварительно установлена).
```
make
```
Либо
```go
go build -o playlist.exe ./cmd/playlist
```
Для запуска используйте команду:
```
$ ./playlist.exe
```

### Запуск тестов

Установите зависимости с помощью `go mod download`

Запуск тестов возможен с помощью утилиты cmake (если она предварительно установлена).
```
make test
```
Либо
```go
go test ./internal/playlist
```

### Эндпоинты

- Для управления песнями

`
GET /song 
` - возвращает все песни в плейлисте

`
POST /song
` - добавляет песню в плейлист

`
GET /song/{idx}
` - возвращает песню с номером idx

`
UPDATE /song/{idx}
` - изменяет песню с номером idx

`
DELETE /song/{idx}
` - удаляет песню с номером idx


- Для управления плейлистом

`
GET /play
` - начинает проигрывание

`
GET /pause
` - ставит проигрывание на паузу

`
GET /next
` - переключает на следующую песню

`
GET /prev
` - переключает на предыдущую песню

`
GET /status
` - получить текущее состояние плэйлиста


### Выполнил
Артём Галкин igalart2000@gmail.com
